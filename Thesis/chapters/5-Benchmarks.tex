\chapter{Benchmarks}\label{chap:benchmarks}
With the model implemented, I was able to evaluate its performance.
All benchmarks were executed on an Intel Core i5-6200U using the
btormc model checker, which is distributed with the BTOR2 format
\cite{btor2}. Each test was run five times, and the resulting times
were averaged. I also attempted to run the tests with the model
checkers AVR \cite{avrPaper} and Pono \cite{ponoPaper}. The
challenges encountered with these tools are discussed in
\secref{sec:results}.

\section{Tests}
I devised two basic tests, each composed of four RISC-V instructions
as illustrated in \figref{fig:base_test_risc}. One test includes a
memory operation, while the other does not, allowing for measurement
of the impact of memory operations on the model's performance. The
programs for these tests are intentionally similar: both feature
three instructions forming a loop and one instruction serving as a
\enquote{workhorse}. The test names, \texttt{add} and
\texttt{write\_mem}, are derived from this key instruction. The
program is embedded into a state, as exemplified in
\figref{fig:bench_example}, where the \texttt{add} program is
configured for 256 loops. In this setup, x1 acts as a loop limiter,
x2 as a loop counter, and x3 as an accumulator. The instructions are
placed in the initial bytes of memory. In contrast, the memory
operation test uses x2 as an address to store the first byte of a
register, with x3 serving as this register. Both tests were also
implemented with increasing loop counts up to 2048 to provide a
reference for processing more iterations.

\input{figures/5-Benchmarks/basetest.tex}
\input{figures/5-Benchmarks/add_0256_state.tex}

Additionally, I evaluated the impact of initialized memory on runtime
. For this, I introduced tests with the prefix \texttt{fullmem},
where memory addresses 0x18 to 0xfff were filled with the bit pattern
'0101'. The first four words of memory were filled with the test
program. The fifth word could also be filled , but I opted to leave
it zero-initialized to ensure the test terminates by jumping to this
address and not finding a valid instruction. This guarantees
termination. To further extend this evaluation, I added tests with
double the initialized memory, filling up to address
0x1fff.\todo{benchmark them, add times}

I also investigated the impact of address space size by generating
models from \texttt{add\_0256}, \texttt{add\_1024},
\texttt{write\_mem\_0256}, and \texttt{write\_mem\_1024} with
extended address space. These tests use the prefix
\enquote{extaddr\_\textcolor{Green}{x}}, where \textcolor{Green}{x}
denotes the maximum address length in bits.

Furthermore, I implemented the base \texttt{add} tests in a manner
similar to the BTOR2 model described by F. SchrÃ¶gendorfer in his
master thesis \cite[Chapter 8]{bmcOfLockless}. These tests use the
prefix \enquote{nopc}, as the program counter is abstracted to
activation flags for each instruction. The model generation is
demonstrated using \texttt{nopc\_add\_0256} as an example. First, the
necessary sorts and constants for RISC-V are defined:

\renewcommand{\arraystretch}{0.5}
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l >{\slshape} l}
                \linespread{0.5}
                1  & sort   & \textcolor{Black}{bitvec} & \textcolor{UniBlue}{1}   & bool          \\
                2  & sort   & \textcolor{Black}{bitvec} & \textcolor{UniBlue}{8}   & memcell       \\
                3  & sort   & \textcolor{Black}{bitvec} & \textcolor{UniBlue}{16}  & addressspace  \\
                4  & sort   & \textcolor{Black}{bitvec} & \textcolor{UniBlue}{64}  & register      \\
                5  & sort   & \textcolor{Black}{array}  & \color{UniGrey} 3 2      & Memory        \\
                6  & zero   & 1                         &                          & false         \\
                7  & one    & 1                         &                          & true          \\
                8  & zero   & 2                         &                          & emptymem      \\
                9  & zero   & 4                         &                          & emptyreg      \\
                10 & zero   & 3                         &                          & pcinit        \\
                11 & consth & 3                         & \textcolor{UniBlue}{4}   & pcinc         \\
                12 & consth & 3                         & \textcolor{UniBlue}{10}  & instr1\_pcmod \\
                13 & consth & 4                         & \textcolor{UniBlue}{100} & nloops        \\
        \end{tabular}
\end{center}

With this now the registers and memory can be defined:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\slshape} l}
                99  & state & 3 & pc  \\
                100 & state & 4 & x0  \\
                101 & state & 4 & x1  \\
                102 & state & 4 & x2  \\
                103 & state & 4 & x3  \\
                104 & state & 4 & x4  \\
                105 & state & 4 & x5  \\
                106 & state & 4 & x6  \\
                107 & state & 4 & x7  \\
                108 & state & 4 & x8  \\
                109 & state & 4 & x09 \\
        \end{tabular}\qquad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\slshape} l}
                110 & state & 4 & x10 \\
                111 & state & 4 & x11 \\
                112 & state & 4 & x12 \\
                113 & state & 4 & x13 \\
                114 & state & 4 & x14 \\
                115 & state & 4 & x15 \\
                116 & state & 4 & x16 \\
                117 & state & 4 & x17 \\
                118 & state & 4 & x18 \\
                119 & state & 4 & x19 \\
                120 & state & 4 & x20 \\
        \end{tabular}\qquad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\slshape} l}
                121 & state & 4 & x21 \\
                122 & state & 4 & x22 \\
                123 & state & 4 & x23 \\
                124 & state & 4 & x24 \\
                125 & state & 4 & x25 \\
                126 & state & 4 & x26 \\
                127 & state & 4 & x27 \\
                128 & state & 4 & x28 \\
                129 & state & 4 & x29 \\
                130 & state & 4 & x30 \\
                131 & state & 4 & x31 \\
        \end{tabular}
\end{center}

Note that node IDs 14-98 are skipped. As BTOR2 requires unique but
not continuous node IDs, I assigned each register node ID to equal
the register number plus 100 for clarity when writing models
manually.\\ Next, the initial memory is defined:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniBlue}}l}
                144 & state  & 5 &                           \\
                145 & init   & 5 & \color{UniRed} 14 8       \\
                146 & consth & 3 & 0                         \\
                147 & consth & 2 & e3                        \\
                148 & write  & 5 & \color{UniRed}144 146 147 \\
                149 & consth & 3 & 1                         \\
                150 & consth & 2 & 58                        \\
                151 & write  & 5 & \color{UniRed}148 149 150 \\
                152 & consth & 3 & 2                         \\
                153 & consth & 2 & 11                        \\
                154 & write  & 5 & \color{UniRed}151 152 153 \\
                155 & consth & 3 & 3                         \\
                156 & consth & 2 & 00                        \\
                157 & write  & 5 & \color{UniRed}154 155 156 \\
                158 & consth & 3 & 4                         \\
                159 & consth & 2 & b3                        \\
                160 & write  & 5 & \color{UniRed}157 158 159 \\
                161 & consth & 3 & 5                         \\
                162 & consth & 2 & 81                        \\
                163 & write  & 5 & \color{UniRed} 16 161 162 \\
                164 & consth & 3 & 6                         \\
                165 & consth & 2 & 21                        \\
                166 & write  & 5 & \color{UniRed} 16 164 165 \\
                167 & consth & 3 & 7                         \\
                168 & consth & 2 & 00                        \\
        \end{tabular}\qquad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniBlue}}l }
                169 & write  & 5 & \color{UniRed}166 167 168 \\
                170 & consth & 3 & 8                         \\
                171 & consth & 2 & 13                        \\
                172 & write  & 5 & \color{UniRed}169 170 171 \\
                173 & consth & 3 & 9                         \\
                174 & consth & 2 & 01                        \\
                175 & write  & 5 & \color{UniRed}172 173 174 \\
                176 & consth & 3 & a                         \\
                177 & consth & 2 & 11                        \\
                178 & write  & 5 & \color{UniRed}175 176 177 \\
                179 & consth & 3 & b                         \\
                180 & consth & 2 & 00                        \\
                181 & write  & 5 & \color{UniRed}178 179 180 \\
                182 & consth & 3 & c                         \\
                183 & consth & 2 & 67                        \\
                184 & write  & 5 & \color{UniRed}181 182 183 \\
                185 & consth & 3 & d                         \\
                186 & consth & 2 & 00                        \\
                187 & write  & 5 & \color{UniRed}184 185 186 \\
                188 & consth & 3 & e                         \\
                189 & consth & 2 & 00                        \\
                190 & write  & 5 & \color{UniRed}187 188 189 \\
                191 & consth & 3 & f                         \\
                192 & consth & 2 & 00                        \\
                193 & write  & 5 & \color{UniRed}190 191 192
        \end{tabular}
\end{center}

Due to BTOR2 constraints, initial memory must be defined before the
intended memory state node. Node 144 serves only for memory
initialization, as previously described in
\secref{sec:initialization}.\\ The actual memory state and
instruction flags are then defined. I renamed the flags from
\texttt{stmt} (SchrÃ¶gendorfer) to \texttt{instr} for clarity. An exit
code is unnecessary, as differentiation between model terminations is
not required; only the termination time is of interest.
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\slshape}l }
                199 & state & 5 & memory  \\
                200 & state & 1 & instr0  \\
                201 & state & 1 & instr1  \\
                202 & state & 1 & instr2  \\
                203 & state & 1 & instr3  \\
                204 & state & 1 & endflag \\
        \end{tabular}
\end{center}

Next up would be the inputs and constraints for these. Both are not
needed for the RISC-V model because neither are threads needed as I
do not model parallel processing, nor is flushing as I use a naive
memory model. And without inputs, the constraints are also
nonexistent. So really, next up is initialization and transitions of
the states. First is pc:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l | >{\itshape} l}
                300 & init & 3 & 99  & 10  &     & pc is zero initialized                 \\
                301 & add  & 3 & 99  & 11  &     & normal pc operation                    \\
                302 & add  & 3 & 99  & 12  &     & instr1 jump                            \\
                303 & eq   & 1 & 101 & 102 &     & instr1 branch condition                \\
                304 & ite  & 3 & 303 & 302 & 301 & IF condition THEN jump ELSE increment  \\
                305 & ite  & 3 & 200 & 304 & 99  & IF instr1 THEN check ELSE leave pc     \\
                306 & or   & 1 & 201 & 202 &     & instr2-3                               \\
                307 & ite  & 3 & 306 & 301 & 305 & IF instr2-3 THEN increment ELSE instr1 \\
                308 & ite  & 3 & 203 & 10  & 307 & IF instr4 THEN jump0 ELSE try instr2-3 \\
                309 & next & 3 & 99  & 308
        \end{tabular}
\end{center}

As the transition for pc are quite possibly the most complex I added
some explanation. x0 and x1 are skipped for now, so next registers x2
and x3:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l}
                314 & init & 4 & 102 & 9         \\
                315 & one  & 4 &                 \\
                316 & add  & 4 & 102 & 315       \\
                317 & ite  & 4 & 202 & 316 & 102 \\
                318 & next & 4 & 102 & 317       \\
        \end{tabular}\qquad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l}
                319 & init & 4 & 103 & 9         \\
                320 & add  & 4 & 102 & 103       \\
                321 & ite  & 4 & 201 & 320 & 103 \\
                322 & next & 4 & 103 & 321       \\\\
        \end{tabular}
\end{center}

x2 increments by one each time the third instruction is run and x3
adds x2 every time the second instruction is run. All other registers
and the memory do not change during execution, so I show them in one
big block:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l }
                310 & init \color{UniGrey} 4 \color{UniRed} 100 9   \\
                311 & next \color{UniGrey} 4 \color{UniRed} 100 100 \\
                312 & init \color{UniGrey} 4 \color{UniRed} 101 13  \\
                313 & next \color{UniGrey} 4 \color{UniRed} 101 101 \\
                323 & init \color{UniGrey} 4 \color{UniRed} 104 9   \\
                324 & next \color{UniGrey} 4 \color{UniRed} 104 104 \\
                325 & init \color{UniGrey} 4 \color{UniRed} 105 9   \\
                326 & next \color{UniGrey} 4 \color{UniRed} 105 105 \\
                327 & init \color{UniGrey} 4 \color{UniRed} 106 9   \\
                328 & next \color{UniGrey} 4 \color{UniRed} 106 106 \\
                329 & init \color{UniGrey} 4 \color{UniRed} 107 9   \\
                330 & next \color{UniGrey} 4 \color{UniRed} 107 107 \\
                331 & init \color{UniGrey} 4 \color{UniRed} 108 9   \\
                332 & next \color{UniGrey} 4 \color{UniRed} 108 108 \\
                333 & init \color{UniGrey} 4 \color{UniRed} 109 9   \\
                334 & next \color{UniGrey} 4 \color{UniRed} 109 109 \\
                335 & init \color{UniGrey} 4 \color{UniRed} 110 9   \\
                336 & next \color{UniGrey} 4 \color{UniRed} 110 110 \\
                337 & init \color{UniGrey} 4 \color{UniRed} 111 9   \\
                338 & next \color{UniGrey} 4 \color{UniRed} 111 111 \\
                339 & init \color{UniGrey} 4 \color{UniRed} 112 9   \\
        \end{tabular}\quad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l }
                340 & next \color{UniGrey} 4 \color{UniRed} 112 112 \\
                341 & init \color{UniGrey} 4 \color{UniRed} 113 9   \\
                342 & next \color{UniGrey} 4 \color{UniRed} 113 113 \\
                343 & init \color{UniGrey} 4 \color{UniRed} 114 9   \\
                344 & next \color{UniGrey} 4 \color{UniRed} 114 114 \\
                345 & init \color{UniGrey} 4 \color{UniRed} 115 9   \\
                346 & next \color{UniGrey} 4 \color{UniRed} 115 115 \\
                347 & init \color{UniGrey} 4 \color{UniRed} 116 9   \\
                348 & next \color{UniGrey} 4 \color{UniRed} 116 116 \\
                349 & init \color{UniGrey} 4 \color{UniRed} 117 9   \\
                350 & next \color{UniGrey} 4 \color{UniRed} 117 117 \\
                351 & init \color{UniGrey} 4 \color{UniRed} 118 9   \\
                352 & next \color{UniGrey} 4 \color{UniRed} 118 118 \\
                353 & init \color{UniGrey} 4 \color{UniRed} 119 9   \\
                354 & next \color{UniGrey} 4 \color{UniRed} 119 119 \\
                355 & init \color{UniGrey} 4 \color{UniRed} 120 9   \\
                356 & next \color{UniGrey} 4 \color{UniRed} 120 120 \\
                357 & init \color{UniGrey} 4 \color{UniRed} 121 9   \\
                358 & next \color{UniGrey} 4 \color{UniRed} 121 121 \\
                359 & init \color{UniGrey} 4 \color{UniRed} 122 9   \\
                360 & next \color{UniGrey} 4 \color{UniRed} 122 122 \\
        \end{tabular}\quad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l  }
                361 & init \color{UniGrey} 4 \color{UniRed} 123 9   \\
                362 & next \color{UniGrey} 4 \color{UniRed} 123 123 \\
                363 & init \color{UniGrey} 4 \color{UniRed} 124 9   \\
                364 & next \color{UniGrey} 4 \color{UniRed} 124 124 \\
                365 & init \color{UniGrey} 4 \color{UniRed} 125 9   \\
                366 & next \color{UniGrey} 4 \color{UniRed} 125 125 \\
                367 & init \color{UniGrey} 4 \color{UniRed} 126 9   \\
                368 & next \color{UniGrey} 4 \color{UniRed} 126 126 \\
                369 & init \color{UniGrey} 4 \color{UniRed} 127 9   \\
                370 & next \color{UniGrey} 4 \color{UniRed} 127 127 \\
                371 & init \color{UniGrey} 4 \color{UniRed} 128 9   \\
                372 & next \color{UniGrey} 4 \color{UniRed} 128 128 \\
                373 & init \color{UniGrey} 4 \color{UniRed} 129 9   \\
                374 & next \color{UniGrey} 4 \color{UniRed} 129 129 \\
                375 & init \color{UniGrey} 4 \color{UniRed} 130 9   \\
                376 & next \color{UniGrey} 4 \color{UniRed} 130 130 \\
                377 & init \color{UniGrey} 4 \color{UniRed} 131 9   \\
                378 & next \color{UniGrey} 4 \color{UniRed} 131 131 \\
                379 & init \color{UniGrey} 5 \color{UniRed} 199 193 \\
                380 & next \color{UniGrey} 5 \color{UniRed} 199 199
        \end{tabular}
\end{center}

Now only the instruction flags are left to handle:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l | >{\itshape}l}
                381 & init & 1                 & 200 7    & instr0 executes initally               \\
                382 & next & 1                 & 200 203  & instr0 only after instr3               \\
                383 & init & 1                 & 201 6                                             \\
                384 & and  & 1                 & 200 -303 & instr0 and no branch                   \\
                385 & next & 1                 & 201 384  & instr1 only after non-branching instr0 \\
                386 & init & 1                 & 202 6                                             \\
                387 & next & 1                 & 202 201  & instr2 only after instr2               \\
                388 & init & 1                 & 203 6                                             \\
                389 & next & 1                 & 203 202  & instr3 only after instr3               \\
                390 & init & 1                 & 204 6                                             \\
                391 & and  & 1                 & 200 303                                           \\
                392 & next & 1                 & 204 391  & endflag if instr0 branches             \\
                400 & bad  & \color{UniRed}204 &          & endflag terminates                     \\
        \end{tabular}
\end{center}
\renewcommand{\arraystretch}{1}

And with this, the model is can be run. The whole suite of add tests
can be derived from this model by changing the constant value of node
13 to the appropriate loop count.

\section{Results} \label{sec:results}

To start I placed all iterations based benchmarks with btormc into
\tabref{tab:time_iter} and the benchmarks of extended address space
into \tabref{tab:time_extaddr}. From \tabref{tab:time_extaddr} one
can assume that the extension of address space does not impact the
runtime of the model checker in a meaningful way. As seen in
\tabref{tab:time_rel}, with rising loop counts, memory operations
need increasingly more time in comparison to their respective
non-memory operation benchmarks. Also with rising loop counts the
impact of large amounts of memory initialised is reduced, which was
to be expected.

The \texttt{nopc} benchmark is significantly faster than my model.
This was to be expected, as SchrÃ¶gendorfer models one RISC-V program
specifically whereas I model the processor and feed it different
programs by initialization. In this perspective, it is not surprising
that a specialised model is faster than a generalised one. \todo{Add
        example for finding an instruction?}

\input{figures/5-Benchmarks/timetables.tex}
\input{figures/5-Benchmarks/relative_times.tex}

I also attempted to benchmark with the AVR and Pono model checkers,
as they ranked first and second in the 2024 hardware model checking
competition. Unfortunately, AVR did not terminate within 15 minutes
when checking the \texttt{add\_0256} benchmark. Pono determined that
this benchmark is satisfiable, but required nearly six minutes using
the \texttt{--smt-solver cvc5} option. With \texttt{--smt-solver
        bzla}, Pono was slower but functional; other solvers reported
inability to handle arrays. These results suggest that model checkers
considered superior in general are not necessarily optimal for my
model, whereas btormc, despite being unmaintained since August 2024,
performed best. I suspect that newer model checkers are optimized for
handling inputs, as most competition benchmarks involve at least one
input beyond a clock signal, while my model operates solely with
known constants and its execution time is dependent on rapid state
iteration.

Another issue with AVR and Pono is their inability to generate a
\enquote{complete} witness, as produced by the btormc option
\texttt{--trace-gen-full}, which provides the values of all states in
the final frame. Without this feature, it is not possible to
reconstruct a state from their output after execution.

%\input{figures/5-Benchmarks/times_plot.tex}