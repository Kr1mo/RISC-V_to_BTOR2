\chapter{Benchmarks}\label{chap:benchmarks}
With a model implemented, I can test how good it runs. I run my
benchmarks on an Intel Core i5-6200U with the btormc model checker
published with the BTOR2 format \cite{btor2}. Each test was run five
times and the resulting times averaged. I also tried to run the tests
with the model checkers avr and pono \todo{cite} as they placed first
and second in the hardware model checking competition of 2024, but I
will talk about them at the results.

\section{Tests}
I devised two base tests formed from four RISC-V instructions as
shown in \figref{fig:base_test_risc}. I chose to implement one test
with and one without memory operation to be able to measure the
impact memory operations have in the model. For this reason the
program for these tests are very similar. Both have three
instructions forming a loop and one instruction as a
\enquote{workhorse}. My naming for these also derive from this
instruction as add and write\_mem. This program is set into a state.
An example for this is found in \figref{fig:bench_example}, where the
add program is set up for 256 loops. In this, x1 acts as a loop
limiter, x2 as a loop counter and x3 as an accumulator. The
instructions are set in the first bytes of the memory. In difference
to this, the memory operation test uses x2 also as an address to
store the first byte of a register and x3 as this register. Both
tests are also implemented with rising loop counts up to 2048 to form
a reference on how they behave with more iterations to process.

\input{figures/5-Benchmarks/basetest.tex}
\input{figures/5-Benchmarks/add_0256_state.tex}

Further on I tested the impact of initialized memory on the runtime
of the test. For this I added tests with the prefix fullmem, where I
filled the memory addresses 0x18 to 0xfff with the pattern '0101'.
The first four words of the memory are not filled for there lies the
program of the test. The fifth could also be filled instead of being
left zero-initialized, but I decided against it because the test is
designed to terminate by jumping to this address and not finding a
valid instruction there. Leaving it zero-initialized guarantees this.
To further extend on this test, I also added some tests on double the
initialized memory, so filled to the address 0x1fff.\todo{benchmark
        them, add times}

I also tested on the impact of the address space size. For this I
generated models from add\_0256, add\_1024, write\_mem\_0256 and
write\_mem\_1024 with extended address space. These tests have the
prefix \enquote{extaddr\_\textcolor{Green}{x}}, where
\textcolor{Green}{x} is the maximum length of an address in this
model in bits.

Finally, I also implemented the base add tests similar to the BTOR2
model that F.Schrögendorfer describes in his master thesis
\cite[Chapter 8]{bmcOfLockless}. These tests have the prefix
\enquote{nopc}, as the pc is abstracted to activation flags for each
instruction. I show the generation of the model on the example of
nopc\_add\_0256. First of, we need the sorts necessary for RISC-V and
the constants necessary for the model:
\renewcommand{\arraystretch}{0.5}
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l >{\slshape} l}
                \linespread{0.5}
                1  & sort   & \textcolor{Black}{bitvec} & \textcolor{UniBlue}{1}   & bool          \\
                2  & sort   & \textcolor{Black}{bitvec} & \textcolor{UniBlue}{8}   & memcell       \\
                3  & sort   & \textcolor{Black}{bitvec} & \textcolor{UniBlue}{16}  & addressspace  \\
                4  & sort   & \textcolor{Black}{bitvec} & \textcolor{UniBlue}{64}  & register      \\
                5  & sort   & \textcolor{Black}{array}  & \color{UniGrey} 3 2      & Memory        \\
                6  & zero   & 1                         &                          & false         \\
                7  & one    & 1                         &                          & true          \\
                8  & zero   & 2                         &                          & emptymem      \\
                9  & zero   & 4                         &                          & emptyreg      \\
                10 & zero   & 3                         &                          & pcinit        \\
                11 & consth & 3                         & \textcolor{UniBlue}{4}   & pcinc         \\
                12 & consth & 3                         & \textcolor{UniBlue}{10}  & instr1\_pcmod \\
                13 & consth & 4                         & \textcolor{UniBlue}{100} & nloops        \\
        \end{tabular}
\end{center}

With this now the registers and memory can be defined:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\slshape} l}
                99  & state & 3 & pc  \\
                100 & state & 4 & x0  \\
                101 & state & 4 & x1  \\
                102 & state & 4 & x2  \\
                103 & state & 4 & x3  \\
                104 & state & 4 & x4  \\
                105 & state & 4 & x5  \\
                106 & state & 4 & x6  \\
                107 & state & 4 & x7  \\
                108 & state & 4 & x8  \\
                109 & state & 4 & x09 \\
        \end{tabular}\qquad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\slshape} l}
                110 & state & 4 & x10 \\
                111 & state & 4 & x11 \\
                112 & state & 4 & x12 \\
                113 & state & 4 & x13 \\
                114 & state & 4 & x14 \\
                115 & state & 4 & x15 \\
                116 & state & 4 & x16 \\
                117 & state & 4 & x17 \\
                118 & state & 4 & x18 \\
                119 & state & 4 & x19 \\
                120 & state & 4 & x20 \\
        \end{tabular}\qquad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\slshape} l}
                121 & state & 4 & x21 \\
                122 & state & 4 & x22 \\
                123 & state & 4 & x23 \\
                124 & state & 4 & x24 \\
                125 & state & 4 & x25 \\
                126 & state & 4 & x26 \\
                127 & state & 4 & x27 \\
                128 & state & 4 & x28 \\
                129 & state & 4 & x29 \\
                130 & state & 4 & x30 \\
                131 & state & 4 & x31 \\
        \end{tabular}
\end{center}

Note that I skipped the node IDs of 14-98. As BTOR2 needs unique but
not continouus node IDs, I took this liberty so each register node ID
equals the register nuber plus 100. By this it becomes easier to
write a model by hand.\\ Next the initial memory is placed in the
model:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniBlue}}l}
                144 & state  & 5 &                           \\
                145 & init   & 5 & \color{UniRed} 14 8       \\
                146 & consth & 3 & 0                         \\
                147 & consth & 2 & e3                        \\
                148 & write  & 5 & \color{UniRed}144 146 147 \\
                149 & consth & 3 & 1                         \\
                150 & consth & 2 & 58                        \\
                151 & write  & 5 & \color{UniRed}148 149 150 \\
                152 & consth & 3 & 2                         \\
                153 & consth & 2 & 11                        \\
                154 & write  & 5 & \color{UniRed}151 152 153 \\
                155 & consth & 3 & 3                         \\
                156 & consth & 2 & 00                        \\
                157 & write  & 5 & \color{UniRed}154 155 156 \\
                158 & consth & 3 & 4                         \\
                159 & consth & 2 & b3                        \\
                160 & write  & 5 & \color{UniRed}157 158 159 \\
                161 & consth & 3 & 5                         \\
                162 & consth & 2 & 81                        \\
                163 & write  & 5 & \color{UniRed} 16 161 162 \\
                164 & consth & 3 & 6                         \\
                165 & consth & 2 & 21                        \\
                166 & write  & 5 & \color{UniRed} 16 164 165 \\
                167 & consth & 3 & 7                         \\
                168 & consth & 2 & 00                        \\
        \end{tabular}\qquad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniBlue}}l }
                169 & write  & 5 & \color{UniRed}166 167 168 \\
                170 & consth & 3 & 8                         \\
                171 & consth & 2 & 13                        \\
                172 & write  & 5 & \color{UniRed}169 170 171 \\
                173 & consth & 3 & 9                         \\
                174 & consth & 2 & 01                        \\
                175 & write  & 5 & \color{UniRed}172 173 174 \\
                176 & consth & 3 & a                         \\
                177 & consth & 2 & 11                        \\
                178 & write  & 5 & \color{UniRed}175 176 177 \\
                179 & consth & 3 & b                         \\
                180 & consth & 2 & 00                        \\
                181 & write  & 5 & \color{UniRed}178 179 180 \\
                182 & consth & 3 & c                         \\
                183 & consth & 2 & 67                        \\
                184 & write  & 5 & \color{UniRed}181 182 183 \\
                185 & consth & 3 & d                         \\
                186 & consth & 2 & 00                        \\
                187 & write  & 5 & \color{UniRed}184 185 186 \\
                188 & consth & 3 & e                         \\
                189 & consth & 2 & 00                        \\
                190 & write  & 5 & \color{UniRed}187 188 189 \\
                191 & consth & 3 & f                         \\
                192 & consth & 2 & 00                        \\
                193 & write  & 5 & \color{UniRed}190 191 192
        \end{tabular}
\end{center}

Due to constraints in BTOR2, the initial memory must be placed before
the intended memory state node. Node 144 is again a state only for
initializing the memory, as I previously did in the initialisation
for my own model found in \secref{sec:initialization}.\\ Now the real
memory state can be defined. With this I also define the flags for
each instruction. I changed their name from stmt (Schrögendorfer) to
instr for increased clarity. An exit code is not necessary as I do
not need differentiation between terminations of the model, more so I
am only interested \emph{when} the model terminates.
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\slshape}l }
                199 & state & 5 & memory  \\
                200 & state & 1 & instr0  \\
                201 & state & 1 & instr1  \\
                202 & state & 1 & instr2  \\
                203 & state & 1 & instr3  \\
                204 & state & 1 & endflag \\
        \end{tabular}
\end{center}

Next up would be the inputs and constraints for these. Both are not
needed for the RISC-V model because neither are threads needed as I
do not model parallel processing, nor is flushing as I use a naive
memory model. And without inputs, the constraints are also
nonexistent. So really, next up is initialization and transitions of
the states. First is pc:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l | >{\itshape} l}
                300 & init & 3 & 99  & 10  &     & pc is zero initialized                 \\
                301 & add  & 3 & 99  & 11  &     & normal pc operation                    \\
                302 & add  & 3 & 99  & 12  &     & instr1 jump                            \\
                303 & eq   & 1 & 101 & 102 &     & instr1 branch condition                \\
                304 & ite  & 3 & 303 & 302 & 301 & IF condition THEN jump ELSE increment  \\
                305 & ite  & 3 & 200 & 304 & 99  & IF instr1 THEN check ELSE leave pc     \\
                306 & or   & 1 & 201 & 202 &     & instr2-3                               \\
                307 & ite  & 3 & 306 & 301 & 305 & IF instr2-3 THEN increment ELSE instr1 \\
                308 & ite  & 3 & 203 & 10  & 307 & IF instr4 THEN jump0 ELSE try instr2-3 \\
                309 & next & 3 & 99  & 308
        \end{tabular}
\end{center}

As the transition for pc are quite possibly the most complex I added
some explanation. x0 and x1 are skipped for now, so next registers x2
and x3:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l}
                314 & init & 4 & 102 & 9         \\
                315 & one  & 4 &                 \\
                316 & add  & 4 & 102 & 315       \\
                317 & ite  & 4 & 202 & 316 & 102 \\
                318 & next & 4 & 102 & 317       \\
        \end{tabular}\qquad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l >{\ttfamily\color{UniRed}}l}
                319 & init & 4 & 103 & 9         \\
                320 & add  & 4 & 102 & 103       \\
                321 & ite  & 4 & 201 & 320 & 103 \\
                322 & next & 4 & 103 & 321       \\\\
        \end{tabular}
\end{center}

x2 increments by one each time the third instruction is run and x3
adds x2 every time the second instruction is run. All other registers
and the memory do not change during execution, so I show them in one
big block:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l }
                310 & init \color{UniGrey} 4 \color{UniRed} 100 9   \\
                311 & next \color{UniGrey} 4 \color{UniRed} 100 100 \\
                312 & init \color{UniGrey} 4 \color{UniRed} 101 13  \\
                313 & next \color{UniGrey} 4 \color{UniRed} 101 101 \\
                323 & init \color{UniGrey} 4 \color{UniRed} 104 9   \\
                324 & next \color{UniGrey} 4 \color{UniRed} 104 104 \\
                325 & init \color{UniGrey} 4 \color{UniRed} 105 9   \\
                326 & next \color{UniGrey} 4 \color{UniRed} 105 105 \\
                327 & init \color{UniGrey} 4 \color{UniRed} 106 9   \\
                328 & next \color{UniGrey} 4 \color{UniRed} 106 106 \\
                329 & init \color{UniGrey} 4 \color{UniRed} 107 9   \\
                330 & next \color{UniGrey} 4 \color{UniRed} 107 107 \\
                331 & init \color{UniGrey} 4 \color{UniRed} 108 9   \\
                332 & next \color{UniGrey} 4 \color{UniRed} 108 108 \\
                333 & init \color{UniGrey} 4 \color{UniRed} 109 9   \\
                334 & next \color{UniGrey} 4 \color{UniRed} 109 109 \\
                335 & init \color{UniGrey} 4 \color{UniRed} 110 9   \\
                336 & next \color{UniGrey} 4 \color{UniRed} 110 110 \\
                337 & init \color{UniGrey} 4 \color{UniRed} 111 9   \\
                338 & next \color{UniGrey} 4 \color{UniRed} 111 111 \\
                339 & init \color{UniGrey} 4 \color{UniRed} 112 9   \\
        \end{tabular}\quad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l }
                340 & next \color{UniGrey} 4 \color{UniRed} 112 112 \\
                341 & init \color{UniGrey} 4 \color{UniRed} 113 9   \\
                342 & next \color{UniGrey} 4 \color{UniRed} 113 113 \\
                343 & init \color{UniGrey} 4 \color{UniRed} 114 9   \\
                344 & next \color{UniGrey} 4 \color{UniRed} 114 114 \\
                345 & init \color{UniGrey} 4 \color{UniRed} 115 9   \\
                346 & next \color{UniGrey} 4 \color{UniRed} 115 115 \\
                347 & init \color{UniGrey} 4 \color{UniRed} 116 9   \\
                348 & next \color{UniGrey} 4 \color{UniRed} 116 116 \\
                349 & init \color{UniGrey} 4 \color{UniRed} 117 9   \\
                350 & next \color{UniGrey} 4 \color{UniRed} 117 117 \\
                351 & init \color{UniGrey} 4 \color{UniRed} 118 9   \\
                352 & next \color{UniGrey} 4 \color{UniRed} 118 118 \\
                353 & init \color{UniGrey} 4 \color{UniRed} 119 9   \\
                354 & next \color{UniGrey} 4 \color{UniRed} 119 119 \\
                355 & init \color{UniGrey} 4 \color{UniRed} 120 9   \\
                356 & next \color{UniGrey} 4 \color{UniRed} 120 120 \\
                357 & init \color{UniGrey} 4 \color{UniRed} 121 9   \\
                358 & next \color{UniGrey} 4 \color{UniRed} 121 121 \\
                359 & init \color{UniGrey} 4 \color{UniRed} 122 9   \\
                360 & next \color{UniGrey} 4 \color{UniRed} 122 122 \\
        \end{tabular}\quad
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l  }
                361 & init \color{UniGrey} 4 \color{UniRed} 123 9   \\
                362 & next \color{UniGrey} 4 \color{UniRed} 123 123 \\
                363 & init \color{UniGrey} 4 \color{UniRed} 124 9   \\
                364 & next \color{UniGrey} 4 \color{UniRed} 124 124 \\
                365 & init \color{UniGrey} 4 \color{UniRed} 125 9   \\
                366 & next \color{UniGrey} 4 \color{UniRed} 125 125 \\
                367 & init \color{UniGrey} 4 \color{UniRed} 126 9   \\
                368 & next \color{UniGrey} 4 \color{UniRed} 126 126 \\
                369 & init \color{UniGrey} 4 \color{UniRed} 127 9   \\
                370 & next \color{UniGrey} 4 \color{UniRed} 127 127 \\
                371 & init \color{UniGrey} 4 \color{UniRed} 128 9   \\
                372 & next \color{UniGrey} 4 \color{UniRed} 128 128 \\
                373 & init \color{UniGrey} 4 \color{UniRed} 129 9   \\
                374 & next \color{UniGrey} 4 \color{UniRed} 129 129 \\
                375 & init \color{UniGrey} 4 \color{UniRed} 130 9   \\
                376 & next \color{UniGrey} 4 \color{UniRed} 130 130 \\
                377 & init \color{UniGrey} 4 \color{UniRed} 131 9   \\
                378 & next \color{UniGrey} 4 \color{UniRed} 131 131 \\
                379 & init \color{UniGrey} 5 \color{UniRed} 199 193 \\
                380 & next \color{UniGrey} 5 \color{UniRed} 199 199
        \end{tabular}
\end{center}

Now only the instruction flags are left to handle:
\begin{center}
        \begin{tabular}[h!]{>{\ttfamily\color{UniRed}}r >{\ttfamily}l >{\ttfamily\color{UniGrey}}l >{\ttfamily\color{UniRed}}l | >{\itshape}l}
                381 & init & 1                 & 200 7    & instr0 executes initally               \\
                382 & next & 1                 & 200 203  & instr0 only after instr3               \\
                383 & init & 1                 & 201 6                                             \\
                384 & and  & 1                 & 200 -303 & instr0 and no branch                   \\
                385 & next & 1                 & 201 384  & instr1 only after non-branching instr0 \\
                386 & init & 1                 & 202 6                                             \\
                387 & next & 1                 & 202 201  & instr2 only after instr2               \\
                388 & init & 1                 & 203 6                                             \\
                389 & next & 1                 & 203 202  & instr3 only after instr3               \\
                390 & init & 1                 & 204 6                                             \\
                391 & and  & 1                 & 200 303                                           \\
                392 & next & 1                 & 204 391  & endflag if instr0 branches             \\
                400 & bad  & \color{UniRed}204 &          & endflag terminates                     \\
        \end{tabular}
\end{center}

And with this, the model is can be run. The whole suite of add tests
can be derived from this model by changing the constant value of node
13 to the appropriate loop count.

\section{Results}

To start I placed all iterations based benchmarks with btormc into
\tabref{tab:time_iter} and the benchmarks of extended address space
into \tabref{tab:time_extaddr}. From \tabref{tab:time_extaddr} one
can assume that the extension of address space does not impact the
runtime of the model checker in a meaningful way. As seen in
\tabref{tab:time_rel}, with rising loop counts, memory operations
need increasingly more time in comparison to their respective
non-memory operation benchmarks. Also with rising loop counts the
impact of large amounts of memory initialised is reduced, which was
to be expected.

The nopc benchmark is significantly faster than my model. This was to
be expected, as Schrögendorfer models one RISC-V program specifically
whereas I model the processor and feed it different programs by
initialization. In this perspective, it is not surprising that a
specialised model is faster than a generalised one. \todo{Add example
        for finding an instruction?}

\input{figures/5-Benchmarks/timetables.tex}
\input{figures/5-Benchmarks/relative_times.tex}

I also wanted to benchmark with the model checkers avr and pono, as
they made first and second place in the hardware model checking
competition 2024. but sadly avr did not terminate in over 15 minutes
when tasked to check the add\_0256 benchmark. Pono found that this
benchmark is satisfiable but also in a non-competitive time of almost
exactly six minutes when using the option \texttt{--smt-solver cvc5}.
With the option \texttt{--smt-solver bzla}, pono always took more
time but worked, other solvers said that they can not handle arrays.
From this I concluded that seemingly better model checkers are not
the best option to run my model but btormc, which even is no longer
maintained since August 2024. My best guess for newer model checker
beeing worse at my model is that my model does not handle inputs at
all but only handles with already known constants, whilst probing
through the benchmarks for the model checking competition, they all
seem to involve at least one input apart from a clock signal. So
state of the art model checker are possibly better at handling those
inputs but not at iterating to the next state as fast as possible.

There is also another problem with avr and pono. In
\secref{sec:corectness} I already wrote about transitioning from a
witness back to a state, but for this, a \enquote{complete} witness
as generated by the btormc option \texttt{--trace-gen-full}, which
shows the values of all states in the last frame, is needed. avr and
pono have no option to generate a complete witness and by this, after
they have run it is not possible to generate a state from their
output.
%\input{figures/5-Benchmarks/times_plot.tex}